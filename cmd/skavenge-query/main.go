// Code generated by generate-query-cli. DO NOT EDIT.

package main

import (
	"context"
	"flag"
	"fmt"
	"math/big"
	"os"
	"time"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/deelawn/skavenge/eth/bindings"
)

const (
	defaultNodeAddress = "http://localhost:8545"
)

func main() {
	// Define flags
	nodeAddress := flag.String("node", defaultNodeAddress, "Ethereum node address")
	flag.Usage = printUsage

	flag.Parse()

	// Get contract address from environment variable
	contractAddressStr := os.Getenv("SKAVENGE_CONTRACT_ADDRESS")
	if contractAddressStr == "" {
		fmt.Fprintf(os.Stderr, "Error: SKAVENGE_CONTRACT_ADDRESS environment variable not set\n")
		os.Exit(1)
	}

	if !common.IsHexAddress(contractAddressStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid contract address: %s\n", contractAddressStr)
		os.Exit(1)
	}

	contractAddress := common.HexToAddress(contractAddressStr)

	// Get the command
	args := flag.Args()
	if len(args) < 1 {
		printUsage()
		os.Exit(1)
	}

	command := args[0]

	// Connect to Ethereum node
	client, err := ethclient.Dial(*nodeAddress)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error connecting to node: %v\n", err)
		os.Exit(1)
	}
	defer client.Close()

	// Create contract instance
	contract, err := bindings.NewSkavengeCaller(contractAddress, client)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating contract instance: %v\n", err)
		os.Exit(1)
	}

	// Execute command
	ctx, cancel := context.WithTimeout(context.Background(), time.Second * 5)
	defer cancel()
	opts := &bind.CallOpts{Context: ctx}

	switch command {
	case "authorized-minter":
		execAuthorizedMinter(contract, opts)
	case "get-current-token-id":
		execGetCurrentTokenId(contract, opts)
	case "get-total-clues-for-sale":
		execGetTotalCluesForSale(contract, opts)
	case "name":
		execName(contract, opts)
	case "symbol":
		execSymbol(contract, opts)
	case "t-r-a-n-s-f-e-r-t-i-m-e-o-u-t":
		execTRANSFERTIMEOUT(contract, opts)
	case "total-supply":
		execTotalSupply(contract, opts)
	case "balance-of":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: balance-of requires an address argument\n")
			os.Exit(1)
		}
		execBalanceOf(contract, opts, args[1])
	case "active-transfer-ids":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: active-transfer-ids requires arg0 argument(s)\n")
			os.Exit(1)
		}
		execActiveTransferIds(contract, opts, args[1])
	case "clues":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: clues requires arg0 argument(s)\n")
			os.Exit(1)
		}
		execClues(contract, opts, args[1])
	case "clues-for-sale":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: clues-for-sale requires arg0 argument(s)\n")
			os.Exit(1)
		}
		execCluesForSale(contract, opts, args[1])
	case "get-approved":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: get-approved requires tokenId argument(s)\n")
			os.Exit(1)
		}
		execGetApproved(contract, opts, args[1])
	case "get-clue-contents":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: get-clue-contents requires tokenId argument(s)\n")
			os.Exit(1)
		}
		execGetClueContents(contract, opts, args[1])
	case "get-r-value":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: get-r-value requires tokenId argument(s)\n")
			os.Exit(1)
		}
		execGetRValue(contract, opts, args[1])
	case "owner-of":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: owner-of requires tokenId argument(s)\n")
			os.Exit(1)
		}
		execOwnerOf(contract, opts, args[1])
	case "token-by-index":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: token-by-index requires index argument(s)\n")
			os.Exit(1)
		}
		execTokenByIndex(contract, opts, args[1])
	case "token-u-r-i":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: token-u-r-i requires tokenId argument(s)\n")
			os.Exit(1)
		}
		execTokenURI(contract, opts, args[1])
	case "transfer-in-progress":
		if len(args) < 2 {
			fmt.Fprintf(os.Stderr, "Error: transfer-in-progress requires arg0 argument(s)\n")
			os.Exit(1)
		}
		execTransferInProgress(contract, opts, args[1])
	case "generate-transfer-id":
		if len(args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: generate-transfer-id requires buyer, tokenId arguments\n")
			os.Exit(1)
		}
		execGenerateTransferId(contract, opts, args[1], args[2])
	case "get-clues-for-sale":
		if len(args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: get-clues-for-sale requires offset, limit arguments\n")
			os.Exit(1)
		}
		execGetCluesForSale(contract, opts, args[1], args[2])
	case "is-approved-for-all":
		if len(args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: is-approved-for-all requires owner, operator arguments\n")
			os.Exit(1)
		}
		execIsApprovedForAll(contract, opts, args[1], args[2])
	case "token-of-owner-by-index":
		if len(args) < 3 {
			fmt.Fprintf(os.Stderr, "Error: token-of-owner-by-index requires owner, index arguments\n")
			os.Exit(1)
		}
		execTokenOfOwnerByIndex(contract, opts, args[1], args[2])
	default:
		fmt.Fprintf(os.Stderr, "Error: Unknown command: %s\n", command)
		printUsage()
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Fprintf(os.Stderr, `Skavenge Contract Query Tool

Usage: skavenge-query [options] <command> [arguments]

Environment Variables:
  SKAVENGE_CONTRACT_ADDRESS    Contract address (required)

Options:
  -node string    Ethereum node address (default: http://localhost:8545)

Available Commands:

  No Arguments:
    authorized-minter                       Get AuthorizedMinter
    get-current-token-id                    Get GetCurrentTokenId
    get-total-clues-for-sale                Get GetTotalCluesForSale
    name                                    Get Name
    symbol                                  Get Symbol
    t-r-a-n-s-f-e-r-t-i-m-e-o-u-t           Get TRANSFERTIMEOUT
    total-supply                            Get TotalSupply

  Single Argument Commands:
    balance-of <address>                    Get BalanceOf
    active-transfer-ids <arg0>           Get ActiveTransferIds
    clues <arg0>                         Get Clues
    clues-for-sale <arg0>                Get CluesForSale
    get-approved <tokenId>                  Get GetApproved
    get-clue-contents <tokenId>             Get GetClueContents
    get-r-value <tokenId>                   Get GetRValue
    owner-of <tokenId>                      Get OwnerOf
    token-by-index <index>                Get TokenByIndex
    token-u-r-i <tokenId>                   Get TokenURI
    transfer-in-progress <arg0>          Get TransferInProgress

  Two Argument Commands:
    generate-transfer-id <buyer> <tokenId>Get GenerateTransferId
    get-clues-for-sale <offset> <limit>  Get GetCluesForSale
    is-approved-for-all <owner> <operator> Get IsApprovedForAll
    token-of-owner-by-index <owner> <index>Get TokenOfOwnerByIndex

Examples:
  export SKAVENGE_CONTRACT_ADDRESS=0x1234567890123456789012345678901234567890
  skavenge-query name
  skavenge-query -node http://localhost:8545 total-supply
  skavenge-query balance-of 0xabcdefabcdefabcdefabcdefabcdefabcdefabcd
  skavenge-query owner-of 1
`)
}

// Command implementations

func execAuthorizedMinter(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.AuthorizedMinter(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.Hex())
}

func execGetCurrentTokenId(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.GetCurrentTokenId(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}

func execGetTotalCluesForSale(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.GetTotalCluesForSale(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}

func execName(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.Name(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}

func execSymbol(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.Symbol(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}

func execTRANSFERTIMEOUT(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.TRANSFERTIMEOUT(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}

func execTotalSupply(contract *bindings.SkavengeCaller, opts *bind.CallOpts) {
	result, err := contract.TotalSupply(opts)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}



func execBalanceOf(contract *bindings.SkavengeCaller, opts *bind.CallOpts, addressStr string) {
	if !common.IsHexAddress(addressStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid address: %s\n", addressStr)
		os.Exit(1)
	}
	address := common.HexToAddress(addressStr)
	result, err := contract.BalanceOf(opts, address)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}



func execActiveTransferIds(contract *bindings.SkavengeCaller, opts *bind.CallOpts, arg0Str string) {
	arg0 := new(big.Int)
	arg0, ok := arg0.SetString(arg0Str, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid arg0: %s\n", arg0Str)
		os.Exit(1)
	}
	result, err := contract.ActiveTransferIds(opts, arg0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("0x%x\n", result)
}

func execClues(contract *bindings.SkavengeCaller, opts *bind.CallOpts, arg0Str string) {
	arg0 := new(big.Int)
	arg0, ok := arg0.SetString(arg0Str, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid arg0: %s\n", arg0Str)
		os.Exit(1)
	}
	result, err := contract.Clues(opts, arg0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	// Struct output - print all fields
	fmt.Printf("%+v\n", result)
}

func execCluesForSale(contract *bindings.SkavengeCaller, opts *bind.CallOpts, arg0Str string) {
	arg0 := new(big.Int)
	arg0, ok := arg0.SetString(arg0Str, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid arg0: %s\n", arg0Str)
		os.Exit(1)
	}
	result, err := contract.CluesForSale(opts, arg0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}

func execGetApproved(contract *bindings.SkavengeCaller, opts *bind.CallOpts, tokenIdStr string) {
	tokenId := new(big.Int)
	tokenId, ok := tokenId.SetString(tokenIdStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.GetApproved(opts, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.Hex())
}

func execGetClueContents(contract *bindings.SkavengeCaller, opts *bind.CallOpts, tokenIdStr string) {
	tokenId := new(big.Int)
	tokenId, ok := tokenId.SetString(tokenIdStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.GetClueContents(opts, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("0x%x\n", result)
}

func execGetRValue(contract *bindings.SkavengeCaller, opts *bind.CallOpts, tokenIdStr string) {
	tokenId := new(big.Int)
	tokenId, ok := tokenId.SetString(tokenIdStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.GetRValue(opts, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}

func execOwnerOf(contract *bindings.SkavengeCaller, opts *bind.CallOpts, tokenIdStr string) {
	tokenId := new(big.Int)
	tokenId, ok := tokenId.SetString(tokenIdStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.OwnerOf(opts, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.Hex())
}

func execTokenByIndex(contract *bindings.SkavengeCaller, opts *bind.CallOpts, indexStr string) {
	index := new(big.Int)
	index, ok := index.SetString(indexStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid index: %s\n", indexStr)
		os.Exit(1)
	}
	result, err := contract.TokenByIndex(opts, index)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}

func execTokenURI(contract *bindings.SkavengeCaller, opts *bind.CallOpts, tokenIdStr string) {
	tokenId := new(big.Int)
	tokenId, ok := tokenId.SetString(tokenIdStr, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.TokenURI(opts, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}

func execTransferInProgress(contract *bindings.SkavengeCaller, opts *bind.CallOpts, arg0Str string) {
	arg0 := new(big.Int)
	arg0, ok := arg0.SetString(arg0Str, 10)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid arg0: %s\n", arg0Str)
		os.Exit(1)
	}
	result, err := contract.TransferInProgress(opts, arg0)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}



func execGenerateTransferId(contract *bindings.SkavengeCaller, opts *bind.CallOpts, buyerStr, tokenIdStr string) {
	if !common.IsHexAddress(buyerStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid buyer address: %s\n", buyerStr)
		os.Exit(1)
	}
	buyer := common.HexToAddress(buyerStr)
	tokenId := new(big.Int)
	tokenId, ok1 := tokenId.SetString(tokenIdStr, 10)
	if !ok1 {
		fmt.Fprintf(os.Stderr, "Error: Invalid tokenId: %s\n", tokenIdStr)
		os.Exit(1)
	}
	result, err := contract.GenerateTransferId(opts, buyer, tokenId)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Printf("0x%x\n", result)
}

func execGetCluesForSale(contract *bindings.SkavengeCaller, opts *bind.CallOpts, offsetStr, limitStr string) {
	offset := new(big.Int)
	offset, ok0 := offset.SetString(offsetStr, 10)
	if !ok0 {
		fmt.Fprintf(os.Stderr, "Error: Invalid offset: %s\n", offsetStr)
		os.Exit(1)
	}
	limit := new(big.Int)
	limit, ok1 := limit.SetString(limitStr, 10)
	if !ok1 {
		fmt.Fprintf(os.Stderr, "Error: Invalid limit: %s\n", limitStr)
		os.Exit(1)
	}
	result, err := contract.GetCluesForSale(opts, offset, limit)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	// Struct output - print all fields
	fmt.Printf("%+v\n", result)
}

func execIsApprovedForAll(contract *bindings.SkavengeCaller, opts *bind.CallOpts, ownerStr, operatorStr string) {
	if !common.IsHexAddress(ownerStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid owner address: %s\n", ownerStr)
		os.Exit(1)
	}
	owner := common.HexToAddress(ownerStr)
	if !common.IsHexAddress(operatorStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid operator address: %s\n", operatorStr)
		os.Exit(1)
	}
	operator := common.HexToAddress(operatorStr)
	result, err := contract.IsApprovedForAll(opts, owner, operator)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result)
}

func execTokenOfOwnerByIndex(contract *bindings.SkavengeCaller, opts *bind.CallOpts, ownerStr, indexStr string) {
	if !common.IsHexAddress(ownerStr) {
		fmt.Fprintf(os.Stderr, "Error: Invalid owner address: %s\n", ownerStr)
		os.Exit(1)
	}
	owner := common.HexToAddress(ownerStr)
	index := new(big.Int)
	index, ok1 := index.SetString(indexStr, 10)
	if !ok1 {
		fmt.Fprintf(os.Stderr, "Error: Invalid index: %s\n", indexStr)
		os.Exit(1)
	}
	result, err := contract.TokenOfOwnerByIndex(opts, owner, index)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
	
	fmt.Println(result.String())
}



